generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Usuarios
model User {
  id            String   @id @default(cuid())
  email         String   @unique
  password      String
  name          String
  dni           String   @unique
  phone         String?
  role          UserRole @default(USER)
  emailVerified Boolean  @default(false)
  personalQRCode String? @unique
  personalQRHash String? @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relaciones
  ticketsPurchased   Ticket[]           @relation("TicketOwner")
  ticketsTransferred TicketTransfer[]   @relation("TransferFrom")
  ticketsReceived    TicketTransfer[]   @relation("TransferTo")
  eventsCreated      Event[]
  validations        TicketValidation[]
  orders             Order[]
  favoriteEvents     FavoriteEvent[]
  vendedorProfile    Vendedor?
  porteroProfile     Portero?
  assignedVendedores Vendedor[]         @relation("VendedorAssignedBy")
  assignedPorteros   Portero[]          @relation("PorteroAssignedBy")

  @@index([email])
  @@index([dni])
  @@index([personalQRCode])
  @@index([personalQRHash])
  @@index([role])
}

enum UserRole {
  USER
  ORGANIZER
  ADMIN
  VALIDATOR
  VENDEDOR
  PORTERO
}

// Eventos
model Event {
  id          String   @id @default(cuid())
  title       String
  subtitle    String?
  description String?  @db.Text
  image       String?
  category    String
  date        DateTime
  time        String
  venue       String
  address     String?
  city        String
  latitude    Decimal? @db.Decimal(10, 8)
  longitude   Decimal? @db.Decimal(11, 8)
  organizerId String
  isActive    Boolean  @default(true)
  isPublic    Boolean  @default(true) // true = público, false = privado (solo por link)
  privateLink String?  @unique // Link único para eventos privados
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relaciones
  organizer   User         @relation(fields: [organizerId], references: [id])
  ticketTypes TicketType[]
  tickets     Ticket[]
  orders      Order[]
  favoriteUsers  FavoriteEvent[]
  vendedores  VendedorEvent[]
  referidos   Referido[]
  tandas      Tanda[]

  @@index([organizerId])
  @@index([date])
  @@index([city])
  @@index([category])
  @@index([isActive])
  @@index([isPublic])
  @@index([privateLink])
}

// Tipos de Entrada
model TicketType {
  id           String   @id @default(cuid())
  eventId      String
  name         String
  totalQty     Int
  soldQty      Int      @default(0)
  availableQty Int
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relaciones
  event          Event              @relation(fields: [eventId], references: [id], onDelete: Cascade)
  tickets        Ticket[]
  tandaTicketTypes TandaTicketType[]

  @@index([eventId])
}

// Tandas (Lotes) de Entradas
model Tanda {
  id        String   @id @default(cuid())
  eventId   String
  name      String   // Nombre de la tanda (ej: "Tanda 1", "Tanda 2")
  startDate DateTime // Fecha de inicio de venta
  endDate   DateTime // Fecha de fin de venta
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones
  event           Event              @relation(fields: [eventId], references: [id], onDelete: Cascade)
  tandaTicketTypes TandaTicketType[]

  @@index([eventId])
  @@index([isActive])
  @@index([startDate])
  @@index([endDate])
}

// Relación entre Tanda y TicketType con precio específico
model TandaTicketType {
  id           String   @id @default(cuid())
  tandaId      String
  ticketTypeId String
  price        Decimal  @db.Decimal(10, 2) // Precio específico para esta tanda
  quantity     Int      // Cantidad de entradas disponibles en esta tanda
  soldQty      Int      @default(0) // Cantidad vendida de esta tanda
  availableQty Int      // Cantidad disponible de esta tanda
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relaciones
  tanda     Tanda     @relation(fields: [tandaId], references: [id], onDelete: Cascade)
  ticketType TicketType @relation(fields: [ticketTypeId], references: [id], onDelete: Cascade)

  @@unique([tandaId, ticketTypeId])
  @@index([tandaId])
  @@index([ticketTypeId])
}

// Órdenes de Compra
model Order {
  id            String        @id @default(cuid())
  userId        String
  eventId       String
  totalAmount   Decimal       @db.Decimal(10, 2)
  paymentMethod PaymentMethod
  paymentStatus PaymentStatus @default(PENDING)
  paymentId     String?
  reservedUntil DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  completedAt   DateTime?

  // Relaciones
  user      User      @relation(fields: [userId], references: [id])
  event     Event     @relation(fields: [eventId], references: [id])
  tickets   Ticket[]
  vendedor  Vendedor? @relation("VendedorSales", fields: [vendedorId], references: [id])
  vendedorId String?
  referido  Referido? @relation("ReferidoOrders", fields: [referidoId], references: [id])
  referidoId String?

  @@index([userId])
  @@index([eventId])
  @@index([paymentStatus])
  @@index([vendedorId])
  @@index([referidoId])
}

enum PaymentMethod {
  MERCADOPAGO
  BANK_TRANSFER
  CASH
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
}

// Entradas
model Ticket {
  id           String       @id @default(cuid())
  ticketTypeId String
  eventId      String
  ownerId      String
  orderId      String
  qrCode       String       @unique
  qrHash       String       @unique
  status       TicketStatus @default(ACTIVE)
  purchaseDate DateTime     @default(now())
  scannedAt    DateTime?
  expiresAt    DateTime
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  // Relaciones
  ticketType  TicketType         @relation(fields: [ticketTypeId], references: [id])
  event       Event              @relation(fields: [eventId], references: [id])
  owner       User               @relation("TicketOwner", fields: [ownerId], references: [id])
  order       Order              @relation(fields: [orderId], references: [id])
  transfers   TicketTransfer[]
  validations TicketValidation[]

  @@index([ownerId])
  @@index([eventId])
  @@index([orderId])
  @@index([qrCode])
  @@index([qrHash])
  @@index([status])
  @@index([expiresAt])
}

enum TicketStatus {
  PENDING_PAYMENT
  ACTIVE
  TRANSFERRED
  USED
  EXPIRED
  CANCELLED
}

// Transferencias de Entradas
model TicketTransfer {
  id           String         @id @default(cuid())
  ticketId     String
  fromUserId   String
  toUserId     String?
  toEmail      String?
  transferCode String?        @unique
  qrCode       String?        @unique
  method       TransferMethod @default(EMAIL)
  status       TransferStatus @default(COMPLETED)
  expiresAt    DateTime?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  completedAt  DateTime?

  // Relaciones
  ticket   Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  fromUser User   @relation("TransferFrom", fields: [fromUserId], references: [id])
  toUser   User?  @relation("TransferTo", fields: [toUserId], references: [id])

  @@index([ticketId])
  @@index([fromUserId])
  @@index([toUserId])
  @@index([transferCode])
  @@index([status])
}

enum TransferMethod {
  EMAIL
  QR
}

enum TransferStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
  COMPLETED
}

// Validaciones/Escaneos
model TicketValidation {
  id          String   @id @default(cuid())
  ticketId    String
  validatorId String
  isValid     Boolean
  scannedAt   DateTime @default(now())
  reason      String?
  metadata    Json?

  // Relaciones
  ticket    Ticket @relation(fields: [ticketId], references: [id])
  validator User   @relation(fields: [validatorId], references: [id])

  @@index([ticketId])
  @@index([validatorId])
  @@index([scannedAt])
}

// Vendedor
model Vendedor {
  id                String   @id @default(cuid())
  userId            String   @unique
  assignedBy        String   // ID del organizador/admin que lo asignó
  assignedByUser    User     @relation("VendedorAssignedBy", fields: [assignedBy], references: [id])
  commissionPercent Decimal  @db.Decimal(5, 2) // Porcentaje de comisión (ej: 10.50)
  totalEarnings     Decimal  @default(0) @db.Decimal(10, 2)
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  events    VendedorEvent[]
  referidos Referido[]
  sales     Order[]         @relation("VendedorSales")

  @@index([userId])
  @@index([assignedBy])
  @@index([isActive])
}

// Asignación de eventos a vendedores
model VendedorEvent {
  id          String   @id @default(cuid())
  vendedorId  String
  eventId     String
  ticketLimit Int?     // Cantidad máxima de entradas que puede vender
  soldQty     Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  vendedor Vendedor @relation(fields: [vendedorId], references: [id], onDelete: Cascade)
  event    Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([vendedorId, eventId])
  @@index([vendedorId])
  @@index([eventId])
}

// Links de referido personalizados
model Referido {
  id          String   @id @default(cuid())
  vendedorId  String
  eventId     String
  customCode  String   @unique // Código personalizado del link
  customUrl   String   @unique // URL completa del link
  clickCount  Int      @default(0)
  conversionCount Int  @default(0) // Cantidad de ventas generadas
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  vendedor Vendedor @relation(fields: [vendedorId], references: [id], onDelete: Cascade)
  event    Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  orders   Order[]  @relation("ReferidoOrders")

  @@index([vendedorId])
  @@index([eventId])
  @@index([customCode])
}

// Portero
model Portero {
  id          String   @id @default(cuid())
  userId      String   @unique
  assignedBy  String   // ID del organizador/admin que lo asignó
  assignedByUser User   @relation("PorteroAssignedBy", fields: [assignedBy], references: [id])
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user       User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  // Los escaneos se obtienen a través de la relación con User -> TicketValidation

  @@index([userId])
  @@index([assignedBy])
  @@index([isActive])
}

// Favoritos
model FavoriteEvent {
  id        String   @id @default(cuid())
  userId    String
  eventId   String
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
}
